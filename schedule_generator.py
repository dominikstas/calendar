from transformers import GPT2LMHeadModel, GPT2Tokenizer
import random
import re

def generate_ai_schedule(tasks):
    """
    Generate an AI-powered schedule using GPT-2
    
    :param tasks: List of tasks to be scheduled
    :return: Dictionary of time-based schedule
    """
    # Load pre-trained GPT-2 model and tokenizer
    model = GPT2LMHeadModel.from_pretrained('gpt2')
    tokenizer = GPT2Tokenizer.from_pretrained('gpt2')

    # Prepare task string for input
    task_string = ", ".join(tasks)
    
    # Generate schedule prompt
    prompt = f"Create a daily schedule for these tasks: {task_string}. Here's a suggested time allocation:"

    # Tokenize the prompt
    input_ids = tokenizer.encode(prompt, return_tensors='pt')

    # Generate text
    output = model.generate(
        input_ids, 
        max_length=200, 
        num_return_sequences=1, 
        no_repeat_ngram_size=2
    )

    # Decode the generated text
    generated_text = tokenizer.decode(output[0], skip_special_tokens=True)

    # If generation fails, use a fallback scheduling algorithm
    if not generated_text or len(generated_text) < len(prompt):
        return fallback_schedule_generator(tasks)

    # Parse the generated text to extract time slots
    return parse_generated_schedule(generated_text, tasks)

def fallback_schedule_generator(tasks):
    """
    Fallback method to generate a schedule if AI generation fails
    
    :param tasks: List of tasks to schedule
    :return: Dictionary of time-based schedule
    """
    # Define working hours
    start_hour = 9  # 9 AM
    end_hour = 17   # 5 PM

    # Shuffle tasks to add some randomness
    random.shuffle(tasks)

    # Distribute tasks across working hours
    schedule = {}
    time_slots = [
        f"{h:02d}:00" for h in range(start_hour, end_hour)
    ]

    for i, task in enumerate(tasks):
        if i < len(time_slots):
            schedule[time_slots[i]] = task

    return schedule

def parse_generated_schedule(generated_text, original_tasks):
    """
    Parse the generated text to extract a schedule
    
    :param generated_text: Text generated by GPT-2
    :param original_tasks: Original list of tasks to match against
    :return: Dictionary of time-based schedule
    """
    # Remove the original prompt from the generated text
    generated_text = generated_text.split("Here's a suggested time allocation:")[-1]

    # Try to extract time slots and tasks using regex
    time_task_pattern = r'(\d{1,2}(?::\d{2})?\s*(?:AM|PM)?)\s*-?\s*(.+?)(?=\d{1,2}(?::\d{2})?\s*(?:AM|PM)|$)'
    matches = re.findall(time_task_pattern, generated_text, re.IGNORECASE | re.DOTALL)

    # Create a schedule dictionary
    schedule = {}

    # Match extracted tasks with original tasks
    for time, task_text in matches:
        # Clean up the task text
        task_text = task_text.strip()
        
        # Find the best matching task from original tasks
        best_match = find_best_task_match(task_text, original_tasks)
        
        if best_match:
            schedule[time.strip()] = best_match

    # If no matches found, fall back to default scheduling
    if not schedule:
        return fallback_schedule_generator(original_tasks)

    return schedule

def find_best_task_match(task_text, original_tasks):
    """
    Find the best matching task from original tasks
    
    :param task_text: Text extracted from generated schedule
    :param original_tasks: List of original tasks
    :return: Best matching task or None
    """
    # Convert task text to lowercase for case-insensitive matching
    task_text = task_text.lower()

    # Find exact matches first
    for task in original_tasks:
        if task.lower() in task_text:
            return task

    # If no exact match, find partial matches
    for task in original_tasks:
        if task.lower() in task_text or task_text in task.lower():
            return task

    return None

